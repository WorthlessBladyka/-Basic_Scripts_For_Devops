# Лекция 1
## DNS 

==**DNS (domain name system)** ==- это сервер в котором хранятся данные domain сайта и его ip-адрес. 

При запросе в браузере сайта "youtube", запрос сначала отправляется на dns сервер, чтобы получить ip адрес сайта. После получения ответа, данные с адресом возвращаются в браузер, и только после этого происходит запрос на сайт youtube.

==**Кэш (cache)**== - это временные данные хранящиеся на компьютере или браузере.

Перед запросом ip-адреса сайта у dns сервера, программа проверяет, есть ли уже у неё необходимый ей адрес. Сначало просматривается кэш браузера, затем на самом компьютере. Если проверка не обнаружила необходимые данные на устройстве, то запрос перенаправляется на DNS server.

Время хранения кэша не известно, множество факторов влияющий на место хранения, вплоть от браузера и ОС до настроек провайдера.

## Root and TLD

==**PC User -> Cache browser -> Cache PC -> DNS -> TLD -> Root**==

<p id="tld"> <b><mark>TLD (top-level domain)</mark></b> - это самая последняя часть доменного имени (.com .ru). Это самый верхний уровень доменных имен. </p>

==**Root**== - это самый верхний уровень доменных имен, нулевой уровень, он не отображается в браузера, в строке поиска отображается **точкой** поле TLD ...youtube.com.

Обращение к TLD происходит в том случае, если на устройстве пользователя и DNS сервера в кэше не оказалось адреса искомого домена. А в свою очередь обращение к Root происходит, если и в кэше TLD не оказалось искомого ip адреса.

Для обращения к Root можно ввести после TLD точку =="."== htts://www.youtube.com==.==
## Subdomain

==subdomain.domain.TLD.==
Пример: https:(==protocol==).gl(==subdomain==).google(==domain==).org(==TLD==)

Поддомены обычно используются организациями для создания уникальных имён сайтов для своих подразделений или сервисов, связанных с организацией. Например, доменное имя «cs.example.edu» может использовать в университете для отдела вычислительной техники, и иметь несколько собственных поддоменов, такие как «mail.cs.example.edu» или «www.cs.example.edu».

# Лекция 2
## Client-server architecture
![[4a38175b-11e8-40ae-879c-ab3ce2027089_2008x1252.jpg]]
==Client-server arhitecture==– это модель распределения задач в компьютерной сети, где клиенты запрашивают ресурсы и услуги, а сервера обрабатывают эти запросы, предоставляют данные и управляют ресурсами.

! Самым простым примером демонстрации работы архитектуры будет: client делает запрос на получения доступа на n-ный сайт, этот запрос сначала отправляется на dns сервер для получения адреса искомого сервера, при успешной получении ip запрос дальше идет на server сайта и от туда уже подтягивает html документ со стилями, и если на страницы присутствуют другие файлы (png, jpg, gif), то сервер обращается к базе данных для отправки этих данных клиенту.

![[Снимок экрана от 2025-10-08 12-50-24.png]]

 ==Check on validation== - это процесс проверки данных или кода, на соответствие определенных требований, стандартов, чтобы удостовериться в их конкретной функционнальности и пригодности. Пример: проверка правильности и полноты введённых данных, например, проверка формата электронного адреса или номера телефона перед сохранением.
! Для регистрации на сайте, пользовательски данные должны пройти проверку валидности.
! Проверка валидности может быть интегрирована, так на сервере, так и дополнительно на машине пользователя.
![[Снимок экрана от 2025-10-08 12-08-51 1.png]]

! Запрос регистрации: USER input name/email/password -> check validation to browser(OK) -> request IP-address from DNS -> server check validation(OK) -> Server: check in Database created user account -> Datebase: response to server (not created) -> Server:  Database, create account -> Database: response (OK account created) -> Server: response user (OK to account created).
! Database хранит пароли в зашифрованном виде. Когда сервер проверяет Password on validation при login, ему необходимо еще дешифровать пароль.

==Token==-  средство идентификации пользователя. Различают программные и аппаратные токены.
![[Снимок экрана от 2025-10-08 12-45-32.png]]
![[Снимок экрана от 2025-10-08 12-46-07.png]]

==Программный== токен -  обычно представляет собой зашифрованную последовательность символов, которая позволяет точно идентифицировать объект и определить уровень его привилегий. Он генерируется системой авторизации и привязывается к конкретному сеансу работы, клиенту сети или пакету данных.
==Аппаратный== токен — это устройство, хранящее уникальный пароль или способное генерировать его по определенным правилам. Для аутентификации аппаратный токен можно физически подключить к компьютеру через коммуникационный порт или специальный считыватель. Самые простые аппаратные токены просто выводят уникальный пароль для текущего сеанса на встроенный дисплей.
## MODEL OSI

==Model OSI== (The Open System Interconnection model) - это сетевая модель стеков(связок) сетевых протоколов osi/iso.
! Посредством данной модели различные сетевые устройства могут взаимодействовать друг с другом.
! Модель определяет различные уровни (7 levels). Каждый уровень выполняет определенные ф-ии.

![[Снимок экрана от 2025-10-08 14-16-59.png]]

### Инкапсуляция и Декапсуляция
Когда данные передаются от приложения к пользователю через сеть, каждый сетевой уровень добавляет к ним свою служебную информацию (заголовок) в процессе ==инкапсуляции==. Например, данные от транспортного уровня инкапсулируются в сегмент, затем в пакет на сетевом уровне, и так далее, пока не преобразуются в биты для передачи.
![[312131312.png]]
==Декапсуляция==: по мере того как инкапсулированный пакет достигает своего назначения, процесс идет **в обратном направлении**. На каждом уровне удаляется соответствующий заголовок, и оставшаяся часть данных передается на следующий, более высокий уровень стека, пока исходные данные не станут доступны приложению-получателю.

==Протокол== - это набор правил, определяющих, порядок и способы передачи данных.
==Служба== - предоставляет пользователям или приложению функциональность или возможность сделать что то. Ее можно сравнить с микросервисом. Пример: WWW - дает возможность пользоваться веб-сервером, а email - отправлять почту.

## Популярный вопрос на интервью TCP vs. UDP (and QUIC)

![[Снимок экрана от 2025-10-08 15-02-20.png]]
==Handshake== - рукопожатие. Цель: Установить надежное соединение между клиентом и сервером перед передачей данных.
```
Клиент              Сервер
   │─── SYN ────────────▶│   (SYN = 1, Seq = x)
   │◀── SYN-ACK ────────│   (SYN = 1, ACK = 1, Seq = y, Ack = x+1)
   │─── ACK ────────────▶│   (ACK = 1, Seq = x+1, Ack = y+1)
```
Клиент: Дорова сервер, держи мой случайный флаг, я хочу передать файл, мой статус жду
Сервер: Я подтверждаю получение, отправляю свой флаг, мой статут жду
Клиент: Я подтверждаю получение, мой статус готов, отправляю что готов, нажми готов

### **Традиционный подход (TCP + TLS):**
==**RTT (Round-Trip Time)**== - время прохождения сигнала от клиента к серверу и обратно.
```
Клиент              Сервер           Время
   │── TCP SYN ──────▶│              0.5 RTT
   │◀── SYN+ACK ──────│              1 RTT  
   │── TCP ACK ──────▶│              1.5 RTT
   │── TLS ClientHello ▶│            1.5 RTT
   │◀─ ServerHello ───│             2 RTT
   │◀─ Certificate ───│             2 RTT
   │── TLS Finished ──▶│            2.5 RTT
   │◀─ TLS Finished ──│             3 RTT
   │── Данные ────────▶│            3 RTT
```
Итого: 3 RTT до передачи данных
### **QUIC подход**
##### **1-RTT (Одно круговое путешествие)**
```
Клиент              Сервер           Время
   │── ClientHello ───▶│              0 RTT
   │   (ключи, параметры)             
   │◀─ ServerHello ────│             1 RTT
   │   (подтверждение, сертификат)
   │── Данные ────────▶│             1 RTT
```

Итого: 1 RTT до передачи данных
##### **0-RTT (Нулевое круговое путешествие)**
```
Клиент              Сервер           Время
   │── ClientHello ───▶│              0 RTT
   │   + 0-RTT данные  │
   │◀─ ServerHello ────│             1 RTT
   │   + ответ на данные│

```
Итого: Данные отправляются СРАЗУ (0 RTT)
## ДОП. к лекции 2
### Одноранговые и многоранговые сети

Одноранговая сеть (Peer-to-peer)(P2P) - клиент-клиент, все узлы равны, могут быть как клиентами так и серверами.
- torrent
- skype
Многоранговая сеть (cliet-server architecture) - Централизованная архитектура с четким разделением ролей.
- банки
- web-server
- online games
# ДЗ к лекции 2
## Разница между URL и URI

==**URI**== (Uniform Resource Identifier) - это общая концепция для идентификации любого ресурса.
- `https://example.com/page.html`
- `tel:+1234567890`
- `file:///home/user/document.txt`

==**URL**== (Uniform Resource Locator) - это подмножество URI, которое не только идентифицирует ресурс, но и указывает **как его найти** - его местоположение в сети.
- `https://www.google.com/search?q=linux`
- `http://localhost:8080/api/users`
- `https://github.com/user/repo.git`
##### Простая аналогия
Представьте, что у вас есть человек:
- **URI** = "Иван Иванович" - это идентификатор человека
- **URL** = "город Москва, ул. Тверская, д. 10" - это местоположение человека

Все URL являются URI, но не все URI являются URL!

### Структура
![[url-1.png]]
- протокол - какой протокол используется для передачи фраймов/пакетов
- домен - domain/subdomain
- суффикс - [TLD](#tld) (Top-level domain)
- путь - путь до файла
- ? - начало для параметров
- параметр - передает дополнительные данные на сервер. 
	- фильтр: диапазон ценны выбранным пользователем
	- фильтр: производителей выбранным пользователем
	- сортировка - порядок полечения
	- количество товара на странице
	- какие id хотим вытащить
	- пагинация - разделение контента на несколько страниц для удобства просмотра(куча фоток, много страниц)
- & - начало след. параметра
- \#h1 - якоря (фокус на определенный элемент страницы  
  эж    )
## Длина URL

Регламентировано, какая максимальная длина URL должна быть нет. Обще принято, что длинна не должна превышать 2000 символов.

Максимальная длина для конкретнных систем зависит он многих факторов начиная он браузера и заканчивая настроек на сервере.
## WWW это служба или subdomain?

**WWW - это служба**, которая:
- Работает по принципу **клиент-сервер**
- Использует **HTTP/HTTPS протокол**
- Состоит из **веб-серверов** и **браузеров**
- Обеспечивает доступ к **гипертекстовым документам**
#####  Почему возникает путаница с `www`?
###### Исторически:
- Ранние серверы имели имена по предоставляемым службам
	- `www.company.com` - сервер WWW-службы
	- `ftp.company.com` - сервер FTP-службы
	- `mail.company.com` - сервер почтовой службы
###### Современно:
- `www` стал просто **субдоменом** по соглашению
- Технически WWW-служба может работать на любом домене
- `example.com` и `www.example.com` часто ведут к одному серверу
# Лекция 3 HTTP
## HTTP определение
==**HTTP==** (HyperText Transfer Protocol) - протокол передачи гипертекста. 7 level model OSI. 

Изначально протокол передавал лишь документы в формате HTML, но в современном мире он может передавать любые файлы.
HyperText - это обычный текст, но с ссылочками на другие страницы.

![[Снимок экрана 2025-10-14 в 2.24.26 PM.png]]
## Methodes HTTP

**HTTP методы** указывают **действие**, которое нужно выполнить с ресурсом на сервере, "То есть, действия отправляются с Frontend in Backend и выполняются на сервере".

- GET - получить данные с сервера
- POST - создать сущность(отправить форму)(отправить данные)
- PUT - обновить/отредактировать все поля сущности
- PATCH - обновить/отредактировать  конкретное поле в сущности
- OPTIONS - (отправляется браузером) "похоже на команду ping" получить поддерживаемые методы для ресурса. это HTTP-метод, который используется для получения информации о возможностях сервера или ресурса. Он возвращает список поддерживаемых методов и другую метаинформацию.
- Отправляется когда:
	- Запросы между разными доменами (cross-origin) (Когда ваш сайт на одном домене, а API — на другом домене)
	- "Не простые" запросы (not-simple requests) - это запросы, которые могут изменять данные на сервере (PUT, PATCH, DELETE)
	- Запросы с кастомными заголовками - это заголовки, которые вы придумали сами
- Не отправляются когда:
	- Методы: GET, HEAD, POST
	- Заголовки: только простые (Accept, Accept-Language, Content-Language, Content-Type)
- Как сделать так, чтобы OPTIONS не отправлялся:
	- Настроить Proxy был на одном домене с API
	- Использовать простые запросы
	- Увеличить время хранения кэша для однотипных запросов
	- Вызывать API с сервера, а не с frontend-аt
- DELETE - удалить сущность
- HEAD - Метод запроса
	- Что делает: Запрашивает только заголовки ответа, без самого тела   
	- Зачем: Проверить существование ресурса, размер файла, время изменения без загрузки содержимого
- TRACE - Метод запроса
	- Что делает: Возвращает обратно полученный запрос для диагностики  
	- Аналогия: Инженер формирует запрос -> отправляет request через proxy servers(proxy могу добавлять, изменять, удалять заголовки) -> все это поступает на сервер, он обрабатывает этот запрос и отправляет response инженеру и кладет в body response, те headers, которые пришли к нему в header request
	- Зачем: Отладка проблем с прокси, проверка что запрос не изменяется по пути
- CONNECT - Метод запроса
	- Что делает: Создает туннель к серверу через прокси
	- Зачем: Организация HTTPS-соединения через прокси, VPN-подключения
## Request/Response body (тело запроса и ответа)

!In body response возращаются данные, которые хотел получить USER сайта. То есть, данные о продукте, его цена, страница друга и тд.
!Body идет после headers.

Типы данных body:
- JSON
- HTML
- txt
- XML
- form-data
- и тд
- 
?Если у метода GET request body?
- ты видишь суслика? Нет. А он есть?)))
- Да, тело присутствует, его не кто не видит, его не кто не отправляет, но он есть

## HTTP response STATUS
![[Complete List of HTTP Protocol Status Codes.webp]]
### status code
#### 1xx - не используется (устаревшее) - информационные коды
#### 2xx - код успех. Received, understood, and accepted
- 200 - стандартный ответ
- 201 - запрос был принят, что привело к созданию нового ресурса. (Мы обращаемся к серверу с method POST и сервер должен ответить с status 201).
#### 3xx - перенаправление
- 301 - этот и будущие запросы будут перенаправлены на другой URL. (URL/n-point переехал или сервер переехал)
- 302 - предлагает клиенту перейти на другой URL-адрес
- 304 - not modified - файл не изменился(etag and if-none-match headers)
#### 4xx - ошибки на стороне клиента
- 400 - неправильный запрос. (тело запроса не правильное или валидация не прошла, незаполненое поле и тд )
- 401 - не авторизирован. (Происходит тогда, когда пользователь пытается постучаться к ресурсу, а пользователь не авторизован, закончилось действие токена или токен не прошел проверку валидности или его во все нет. Браузер в свою очередь обычно отсылает на страницу с полями для авторизации(login and password)).
- 402 - Требуется оплата. (Пользователь пытается воспользоваться ресурсом с отсутствующими правами доступа)
- 403 - Запрещено. (Мы залогинены, но у нас нет прав доступа к ресурсу из-за прав доступа) (У маркетолога, к примеру нету доступа к редактированию данных пользователей)(На frontend не должно быть у пользователя зайти на запрещенный ему ресурс, но и на backend должна быть проверка, так как возможна утечка admin-token)
- 404 - Не найдено, ресурс не найден
- 409 - Конфликт. (К примеру, при регестрации мы указываем email and password, и при отправки формы на сервер, сервер должен состыковать данные с database и отправить утвердительный статус или отправит 409 в случае, если такой пользователь, под таким же email уже существует)

Дополнительно:
- 405 - Method not allowed - сервер знает о запрашиваемом ресурсе, но HTTP method не поддерживается для этого конкретного ресурса (к примеру, получение данных через POST или создание сущности через GET)
- 408 Requst timeout - Сервер ждал запрос от клиента, но не дождался в установленное время (запрос со стороны клиента отвалился по timeout(некачественное интернет соединение, сбой сети, большие файлы загружаются медленно))
- 413 Payload too large - тело запроса превышает установленные лимиты
- 414 URL too long - url запроса слишком длинное
```
Пример:

Слишком длинный URL с параметрами
GET /search?q=очень+длинный+поисковый+запрос+с+множеством+слов+[и так 1000 символов] HTTP/1.1

Ответ сервера:
HTTP/1.1 414 URI Too Long
```
	- Типичные сценарии:
		- Очень длинные GET-параметры
		- Глубокие вложенности URL
- 415 Unsupported media type - cервер отказывается обрабатывать запрос, потому что формат данных не поддерживается.(На сервер отправили XML, вместо JSON)
	- Неправильный Content-type
- 418 - I am teapot (пасхалка, тестирование и демонстрация)
- 422 - Сервер понимает тип содержимого и синтаксис запроса, но не может выполнить инструкции из-за семантических ошибок.

```
Пример:

Создание пользователя с невалидными данными
POST /api/users HTTP/1.1
Content-Type: application/json

{
    "email": "invalid-email",
    "age": -5
}

Ответ сервера:
HTTP/1.1 422 Unprocessable Entity
Content-Type: application/json

{
    "errors": [
        {"field": "email", "message": "Invalid email format"},
        {"field": "age", "message": "Age cannot be negative"}
    ]
}
```
	- **Типичные сценарии:**
		- Валидация данных в API
		- Неправильные бизнес-правила
		- Конфликтующие данные
- 429 Too many requests - клиент отправил слишком много запросов за короткое время
Типичные сценарии:
	- DDoS-атаки
	- Слишком агрессивные скраперы    
	- Ошибки в коде, вызывающие бесконечные запросы
#### 5xx - ошибки со стороны сервера
!Разработчики не должны пробрасывать ошибки на frontend, пользователь не должен знать подробностей из-за чего произошла ошибка на стороне сервера, не должно быть строчек кода, это нарушение безопасности.
- 500 - общая ошибка, что-то пошло не так (сервер на доступен)
- 503 - сервер не может обработать запрос (из-за перегрузки или отключения на техническое обслуживание). Как правило, это временное состояние (restart server)
- 502 - Сервер действовал как шлюз или прокси-сервер и получил недействительный ответ от вышестоящего сервера. (Мы обратились к нужному серверу через сервер "прослойку", а сервер "прослойка" при обращении к запрашиваемому серверу не смог его найти)
- 504 - Сервер действовал как шлюз или прокси-сервер и не получил своевременного ответа от вышестоящего сервера. (Таже самая логика, что и в 502 коде, но искомый сервер отвалился по time-out)



## Headers (заголовки и доп. инфо про запрос)
!Есть основные headers и кастомные. Их создают уже на предприятии.
!Методы и статус кода в headers мы не добавляем 
!Есть как requast, так и response headers

Примеры:
- authorization: token
- cookie + set cookie
- content-type: text/html
- content-encoding: gzip
- user-agent: инфо о браузере и общие системе
-  alt-svc header: позволяет серверу сообщить браузеру, что для данного источника можно использовать альтернативную службу при последующих запросах. Например, другой адрес или протокол. Браузер сохраняет эту информацию и при следующем запросе может использовать новую службу.
# ДЗ к лекции 3.1
## Endpoint
[Кратко и по делу](https://youtu.be/r35tbrxdNhk?si=v4Epf8Y15ULtKfkk)
![[Снимок экрана 2025-10-20 в 2.22.24 PM.png]]
![[Снимок экрана 2025-10-20 в 2.22.44 PM.png]]
![[Снимок экрана 2025-10-20 в 2.23.45 PM.png]]
![[Снимок экрана 2025-10-20 в 2.23.59 PM.png]]
## TLS and SSL
[Простая аналогия](https://youtu.be/nsyLWDtWXk0?si=spbrZR9shGDuMfyN)
- TLS и SSL это оба протокола для шифрования данных.
- TLS это приемник/переосмысления протокола SSL. Первая его версия появилась еще в 1996 году. 
- SSL признан устаревшим и небезопасным протоколом за счет устаревших алгоритмов шифрования и не безопасных ключей
- Сейчас принято использовать в старых системах TLS 1.2, а в современных TLS 1.3 
- Оба протокола нацеленны на обеспечение конфидециальности, шифрования и гарантии целостности данных
### Процесс проверки подлиности и handshake ssh
```
			#проверка сертификации
(бр)ClientHello -> 
(с) ServerHello (отправляет инфо. об сертификате, по какому протоколу будет идти безопасное соединение и публичный ключ) -> 
(бр) обращается на сервер сертификации и проверяет подлиность и валидность сертификата ->
			#затем происходит обмен сеансовым ключом(ассиметричное шифрование)
(бр) шифрует публичным ключом сервера и отсылает preMasterKey  ->
(с) дешифрует preMasterKey приватным ключом, с помощью preMasterKey генирирует сеансовый ключ и отсылает его клиенту ->
(бр) отсылает requst сеансовым ключом ->
(c) если все ОК вернет finihed 
			# после чего организуется симметричное шифрование между клиентом и сервером
```
### Работа TLS 1.3
```
|                         |
   |--- ClientHello -------->|
   |<-- ServerHello ---------|
   |<-- EncryptedExtensions -|
   |<-- Certificate ---------|
   |<-- CertificateVerify ---|
   |<-- Finished ------------|
   |                         |
   |--- Finished ----------->|
   |                         |
   |=== Encrypted Data =====>|
   
   ClientHello = {
    "supported_versions": "TLS 1.3",
    "key_share": "клиентские публичные ключи",
    "signature_algorithms": "поддерживаемые алгоритмы",
    "supported_groups": "P-256, X25519",
    "cipher_suites": "AES-256-GCM, ChaCha20-Poly1305" }
    
   ServerHello = {
    "selected_version": "TLS 1.3", 
    "key_share": "серверные публичные ключи",
    "selected_cipher": "AES-256-GCM" }
    
 . Вычисление общего ключа:
	client_private_key + server_public_key = shared_secret
	server_private_key + client_public_key = shared_secret
	
   Начало шифрования
   
```
### SSL сертификат что это? кем выдается? как используется?
**SSL-сертификат** — это цифровой паспорт сайта, который обеспечивает безопасное соединение между браузером и сервером через шифрование данных

**Центры сертификации (Certificate Authorities - CA)**

###### **Типы SSL-сертификатов: По уровню проверки:**
```
# DV (Domain Validation) 
✅ Проверка только домена
✅ Выдача за минуты
✅ Для блогов, личных сайтов

# OV (Organization Validation)
✅ Проверка компании
✅ 1-3 дня выдачи  
✅ Для бизнес-сайтов

# EV (Extended Validation)
✅ Расширенная проверка
✅ 1-5 дней выдачи
✅ Зеленая строка в браузере
✅ Для банков, госучреждений
```
###### Процесс выдачи:
```
Владелец сайта → Центр сертификации → Проверка → Выдача
       ↓                ↓                ↓          ↓
    Запрос CSR      Проверяет         DV/OV/EV   Сертификат
                    домен/компанию    проверка   с подписью CA
```

```
1. Браузер: "Подключись к site.com"
2. Сервер: "Вот мой SSL-сертификат"
3. Браузер: 
   - Проверяет подпись центра сертификации
   - Сверяет домен и срок действия
4. Устанавливается зашифрованное HTTPS-соединение
```

# Лекция 3.2 version http
## version
![[Снимок экрана 2025-10-23 в 1.43.39 PM.png]]
###### Parallel request
![[http2-multiplexing.png]]
Multiplexing - передача нескольких потоков данных по одному каналу связи.

###### Server Push — это технология в HTTP/2, которая позволяет серверу отправлять ресурсы клиенту до того, как клиент их запросит.
```
Обычный HTTP/1.1:
Клиент                Сервер
   |--- GET /index.html -->|
   |<-- index.html --------|
   |                       |
   |--- GET /style.css --->|  # Дополнительный запрос
   |<-- style.css ---------|

 HTTP/2 с Server Push:
Клиент                Сервер
   |--- GET /index.html -->|
   |<-- index.html --------|
   |<-- PUSH style.css ----|  # Сервер сам отправляет ресурс
   |                       |
			#Клиент уже имеет style.css без запроса!
```
## Вопрос: Кто решает какую версию HTTP использовать?
- браузер

- TLS
- HTTP/3: TLS + alt-svc header
## HTTP + TLS (secure HTTPS)
- TLS (Transport layer security) - протокол защиты траспортного уровня
![[Снимок экрана 2025-10-23 в 2.14.48 PM.png]]
3-я версия уже на автомате поддерживает tls вместе с протоколом quic
# Лекция 3.3 Порты

**Порт** - это целое неотрицательное число. 

Порты это однозначного до 5-ти значного значения.

Пояснение: У нас есть глобальный адрес(static ip), который нам выдает провайдер. С его помощью, мы можем себя индентифицировать в глобальной сети интернет. 
Допустим у нас на машине запущенно несколько сервисов (сервис авторизации (x.x.x.x:80), jenkins(x.x.x.x:5050), сервер майнкрафт(x.x.x.x:25565)) и у каждого сервиса есть свой порт (80, 5050, 25565). 
Порты позволяют, постучаться и управлять из вне к конкретному сервису, а также позволяют им общаться локально между с собой.
Админ может закрывать и открывать порты для доступа к миру
Порт резервируется сервисом при запуске. Если на сервере запущенна программа, которая резервирует н-нным портом, запустить другую программу, которая использует тот же порт не выйдет.

Пример: 
- 80 - http
- 443 - https
- 5432 - Postgesql (реляционная база данных)
- 20,21 - FTP (клиент-клиент, передача файлов)
- 22 - SSH (организует защищенное соединение)
- 23 - telnet

# Лекция 4 (Cookie, Cache, Local/Session storage)
## Cache
- **==Cache==** - промежуточное хранилище данных с быстрым доступом, содержащее информацию, которая может быть запрошена с наибольшей вероятностью
!Актуальная информация (==UP-TO-DATE==) берется с database (цены, курс криптовалюты)
- ==Server Cache== - кэширует данные, которые могут быть запрошены с наибольшей вероятностью и не требовательны к актуальности.
	- ==cache servise== (e.v. **Redis**) - отдельный комп с кучей памяти
	- ==in-memory cache== - кэш на сервере хранящийся в **RAM** памяти
		- плюсы: высокие скорости
		- минусы: дороговизна вертикальной масштабируемости и потеря данных при reboot to server
- ==Client cache== - кэш хранящийся на клиенской части. Кэширует картинки, файлы. 

- **Clear-site-data header** - сервер говорит браузер, что он хочет почистить что-то на клиенте
- НО \[limited support\] - не все браузер поддерживают
## Что такое Cache Invalidation?
Это процесс удаление и обновления устаревших данных в кэше сервера, когда они перестают соответствовать актуальным данным в Database. (Пример: у Пети есть каталог содержащий 10 статей. Он решает дополнить репозиторий еще одной статьей....)
- Это может быть как, частичное удаление, полное или дополнение. Настройка может быть разной.
## Кто решает как долго хранить Client Cache?
- **Сервер**
1) Cache-control, Expires header (жесткий кэш)
	- cache control - предоставляет гибкую среду для управления времени хранения кэша (кэшировать везде, только на хосте, время жизни, проверка актуальности)
	- expires header указывает конкретную дату истечения.
2) ETag(отправляет server), if-None-Match(отправляет client) - браузер с помощью значение в этих двух заголовках понимает нужно ли обновлять client cache и может ли клиент подтянуть данные из своего кэша
	- Если client cache пуст или его требуется обновить, браузер отправляет повторно файл и новый ETag header с актуальным значением (Status code 200)
	- Если значение if-None-Match совпало таковым на сервере, то файл тянется из client cache (Status code 304)
	```
	client request(no-cache) ->
	server response(file, ETag header = *****) ->
	last-time...
	client request(if-None-Mathc) ->
			  // сервер проверяет валидность if-none-mathc и если все ок
			  // то отправляет code 304 и клиент pull file with cliet-cache
			  // но если нет..
	server response(file, ETag header = *****, code 200)
	``` 
3) Last-Modified - сервак отправляет, когда последний раз файл менялся, if-Modified-Since - отправляет клиент, когда у него было изменение файла
4) Версионирование файлов
## Cookie
==Cookie== - небольшой фрагмент данных, отправляемый сервером и хранимый на клиенте
- Что хранит
	1) Управление сеансом(токен)
	2) Персонализация (language, цвет страницы) - то что персонализирует пользователь
	3) Трекинг (аналитика, клики, переходы)

Set-Cookie header - уставливает cookie client-у

Атрибуты:
- domain = sub.domain.com - на какой домен или sub-домен сохранить cookie
- path=/ 
- expires, max-age - как долго живут cookie
- secure - это значит, что cookie будут передаваться только по hhtps
- httpOnly - НЕЛЬЗЯ просмотреть/отредактировать конкретные cookie в JS (например token), но в коде страницы будет видны
- SameSite - ащищает от CSRF-атак и предотвращает отправку кук в меж-сайтовых запросах.
```
CSRF — это атака, когда злоумышленник заставляет браузер жертвы выполнить нежелательные действия на другом сайте, где пользователь авторизован.
		//Запросы, которые идут с одного домена на другой.
		//Запрос выполняется как будто от авторизованного пользователя
Межсайтовые запросы - это запросы, которые идут с одного домена на другой.
```

!DevelopTools -> Application -> Cookie - расположение вкладки с cookie
!DevelopTools -> Consol -> "Document.cookie = text.." - добавить cookie в конец документа
## Storage
![[Снимок экрана 2025-10-27 в 10.42.52 PM.png]]
!Тип данных: Если мы хотим передать json or xml file в Storage, то необходимо их преобразовать их сначала в строку.
!Сервер не может на прямую контролировать local or session storage. Но может присылать response header and body. И исходя как написана логика, с помощью них можно записывать ключ-значение local and session storage.
!При **Log-out** скорее всего будут чиститься все storage(контролируется при написании логики на проекте).
### Local storage
Local storage - хранилище данных ключ/значение без срока давности
Может хранить(хранит разную информацию от проекта к проекту, может содержать последний логин с которым пользователем заходил на сайт, через что авторизировался, путь к аватарке)
### Session storage
Session storage - хранилище данных ключ/значение существует в рамках одной вкладки
Может хранить(данные о сессии, аналитике, о платформе).
# ДЗ

## У каких типов файлов какие приоритеты при отправке HTTP запросов?

- не все так однозначно (логика отправки запросов может отличаться от браузера к браузера, операционной системы) ![[Снимок экрана 2025-10-27 в 8.44.42 PM.png]]
	- (24) - приоритет
	- разпределение, примерно. такое
## Как сделать так, чтобы JS код на клиенте не мог прочитать cookie?

## Как сделать так, чтобы cookie передавались только по HTTPS?

## Может ли в значении cookie содержаться пробел?

## Cache API (req/res)

##